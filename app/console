#!/usr/bin/env /usr/local/bin/php
<?php

declare(strict_types=1);

namespace
{
    use App\Context;
    
    use function Format\sf;
    use function Input\infer;
    use function Output\json;
    use function Output\panic;
    use function Output\stream;
    use function Service\path;
    
    defined('APP_PATH') ?: define('APP_PATH', dirname(__FILE__));
    
    (fn(string $service, ...$request) => (new class($service) extends Context {
        private $service;
    
        public function __construct(string $service) {
            $this->service = $service;
        }
        
        public function respond(...$request): void {
            stream((function (...$payload) {
                try {
                    return $this->compute($this->service, ...infer($payload));
                } catch (\Exception $error) {
                    panic($error->getMessage(), [], $error);
                }
            })(...$request));
            
            exit;
        }
    })->respond(...$request))($argv[1], ...array_slice($argv, 2));
    
    function export(...$items): void {
        echo var_export($items, true).PHP_EOL;
    }
    
    function lump(string $name, ...$items): void {
        echo sf('"%s": %s%s', $name, json($items), PHP_EOL);
    }
    
    function debug(...$items) {
        dump(...$items);
        
        return array_slice($items, -1)[0] ?? [];
    }
    
    function dump(...$items): void {
        stream(...$items).PHP_EOL;
    }
    
    function dd(...$items): void {
        dump(...$items);
        
        exit;
    }
}

namespace App
{
    use function Format\sf;
    use function Format\template;
    use function Format\unquote;
    use function Input\infer;
    use function Output\panic;
    use function Service\path;
    
    function property(string $name, $default = null) {
        return array_key_exists($name, $_ENV) ? infer(unquote($_ENV[$name] ?? '')) : $default;
    }
    
    function module(Context $context, string $name): callable {
        if (file_exists($path = path($name))) {
            return require $path;
        };
        
        panic('Module %s not found at %s!', [$name, $path]);
    }
    
    interface Migration
    {
        public function version(): int;
    
        public function forward();
        
        public function backward();
    }
    
    abstract class Context
    {
        public function service(string $name): callable
        {
            return module($this, $name);
        }
        
        public function compute(string $delegate, ...$arguments)
        {
            return $this->service($delegate)(...$arguments);
        }
        
        public function defer(string $delegate, ...$default): callable
        {
            return function(...$arguments) use($delegate, $default) {
                return $this->compute($delegate, ...$arguments ?: $default);
            };
        }
    }
}

namespace Service
{
    use function Format\sf;
    
    function path(string $name): string {
        return sf('%s/%s.php', APP_PATH, format('format\sausage', $name));
    }
    
    function name(string $path): string {
        return trim(format('format\sausage', str_replace([APP_PATH, '.php'], '', $path)), '/');
    }
    
    function ns(string $path, int $offset = 0): string {
        return trim(str_replace('/', '\\',
            dirname(format('format\pascal', $path), $offset)
        ), '\\');
    }
    
    function format(string $method, string $path): string {
        return implode('/', array_map(fn($part) => $method($part), explode('/', $path)));
    }
    
    function implement(string $name): void {
        throw new Todo(sf('TODO: Service \'%s\' is not implemented.', $name, path($name)));
    }
    
    class Todo extends \RuntimeException {}
}

namespace Format
{
    function sf(string $template, ...$properties): string {
        return sprintf($template, ...$properties);
    }
    
    function unquote(string $subject): string {
        return substr($subject, 0, 1).substr($subject, -1) === '""'
            ? substr($subject, 1, -1)
            : $subject;
    }
    
    function wrap(string $subject, string $wrap = PHP_EOL) {
        return $subject ? sf('%s%s%s', $wrap, $subject, $wrap) : '';
    }
    
    function template(string $body, array $properties): string {
        return str_replace(
            array_map(fn(string $var): string => sf('{{ %s }}', $var), array_keys($properties)),
            array_values($properties),
            $body
        );
    }
    
    function pascal(string $input): string {
        return str_replace(' ', '', words(snake($input)));
    }
    
    function camel(string $name): string {
        return lcfirst(pascal($name));
    }
    
    function sausage(string $input): string {
        return str_replace('_', '-', snake($input));
    }
    
    function words(string $input): string {
        return ucwords(str_replace('_', ' ', snake($input)));
    }
    
    function snake(string $input): string {
        return trim(preg_replace('/_{1,}/', '_', preg_replace_callback('/([A-Z])/', static function($match) {
            return '_'.strtolower($match[0]);
        }, str_replace(['-', '/', ' '], '_', $input))), '_');
    }
}

namespace Input
{
    use function Output\json;
    
    /**
     * Give possible JSON-formatted string and attempt to decode.
     *
     * @param string | array $items A possible string or array of strings to try.
     * @return mixed
     */
    function infer($items) {
        if (is_string($items)) {
            $decoded = json_decode($items);
        
            if (!json_last_error()) {
                return $decoded;
            }
        }
        
        if (is_iterable($items)) {
            foreach ($items as &$argument) {
                if (is_string($argument)) {
                    $decoded = json_decode($argument);
            
                    if (!json_last_error()) {
                        $argument = $decoded;
                    }
                }
            }
        }
        
        return $items;
    }
}

namespace Output
{
    use function Format\unquote;
    
    function stream(...$items): void {
        foreach ($items as $item) {
            echo unquote(json($item)).PHP_EOL;
        }
    }
    
    function json($content): string {
        return json_encode($content, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) ?: 'null';
    }
    
    function panic(string $message, array $notes = [], ?\Exception $exception = null): void {
        stream(sprintf($message, ...$notes)).PHP_EOL;
        
        if ($exception) {
            stream((object) [
                'code' => $exception->getCode() ?: 503,
                'message' => $exception->getMessage(),
                'file' => $exception->getFile(),
                'line' => $exception->getLine(),
                'trace' => explode(PHP_EOL, $exception->getTraceAsString()),
            ]);
        }
        
        exit(1);
    }
}
