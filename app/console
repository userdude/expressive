#!/usr/bin/env /usr/local/bin/php
<?php

declare(strict_types=1);

namespace
{
    use App\Context;
    use Domain\Error;
    
    use function Input\infer;
    use function Output\panic;
    use function Output\stream;
    use function Service\path;
    
    function module(Context $context, string $name): callable {
        if (file_exists($path = path($name))) {
            return require $path;
        }
        
        panic('Module %s not found!', [$name], new Error('Missing %s module.', $name));
    }
    
    defined('APP_PATH') ?: define('APP_PATH', dirname(__FILE__));
    defined('APP_CONTEXT') ?: define('APP_CONTEXT', $argv[0]);
    
    (fn(string $request, ...$body) => (new class($request) extends Context {
        private $request;
        
        public function __construct(string $request) {
            parent::__construct();
            
            $this->request = $request;
        }
        
        public function respond(...$message): void {
            echo stream((function (...$payload) {
                try {
                    return $this->compute($this->request, ...infer(...$payload));
                } catch (\Exception $error) {
                    return panic('Error!', $payload, $error);
                }
            })(...$message));
            
            exit;
        }
    })->respond(...$body))($argv[1], ...array_slice($argv, 2));
}

namespace App
{
    use Domain\Error;
    
    abstract class Context
    {
        public function __construct()
        {
            if (!defined('APP_PATH')) {
                throw new Error('Missing required APP_PATH.');
            }
            
            if (!defined('APP_CONTEXT')) {
                throw new Error('Missing required APP_CONTEXT.');
            }
        }
        
        public function service(string $name): callable
        {
            if (function_exists('\module')) {
                return \module($this, $name);
            }
            
            throw new Error('Missing \method().', $name);
        }
        
        public function compute(string $delegate, ...$arguments)
        {
            return $this->service($delegate)(...$arguments);
        }
        
        public function defer(string $delegate, ...$default): callable
        {
            return function(...$arguments) use($delegate, $default) {
                return $this->compute($delegate, ...(
                count($arguments) ? $arguments : $default
                ));
            };
        }
    }
}

namespace Service
{
    function path(string $name): string {
        return sprintf('%s/%s.php', APP_PATH, format('format\sausage', $name));
    }
    
    function name(string $path): string {
        return format('format\sausage', str_replace([APP_PATH, '.php'], '', $path));
    }
    
    function ns(string $path, int $offset = 0): string {
        return trim(str_replace('/', '\\',
            dirname(format('format\pascal', sprintf('App\/\%s', $path)), $offset)
        ), '\\');
    }
    
    function format(string $method, string $path): string {
        return implode('/', array_map(fn($part) => $method($part), explode('/', $path)));
    }
}

namespace Format
{
    function pascal(string $input): string {
        return str_replace(' ', '', words($input));
    }
    
    function camel(string $name): string {
        return lcfirst(pascal($name));
    }
    
    function sausage(string $input): string {
        return str_replace('_', '-', snake($input));
    }
    
    function words(string $input): string {
        return ucwords(str_replace('_', ' ', snake($input)));
    }
    
    function snake(string $input): string {
        return strtolower(preg_replace('/[^_a-z0-9]|_{2,}/i', '_', $input));
    }
}

namespace Domain
{
    class Error extends \DomainException
    {
        public function __construct(string $message, string ...$errors)
        {
            parent::__construct(sprintf($message, ...$errors));
        }
    }
}

namespace Input
{
    function infer(...$arguments): array {
        foreach ($arguments as &$argument) {
            if (is_string($argument)) {
                $decoded = json_decode($argument);
    
                if (!json_last_error()) {
                    $argument = $decoded;
                }
            }
        }
        
        return $arguments;
    }
}

namespace Output
{
    function stream($output): string {
        return (json($output) ?? '').PHP_EOL;
    }
    
    function json($output): ?string {
        $input = stripslashes(json_encode($output, JSON_PRETTY_PRINT) ?: null);
    
        if ($input
            && strpos($input, '"') === 0
            && strrpos($input, '"') + 1 === strlen($input)) {
            $input = substr($input, 1, -1);
        }
        
        return $input;
    }
    
    function panic(string $message, array $notes = [], ?\Exception $exception = null): void {
        echo stream(sprintf($message, ...$notes));
        
        if ($exception) {
            echo stream((object) [
                'code' => $exception->getCode() ?: 503,
                'message' => $exception->getMessage(),
                'file' => $exception->getFile(),
                'line' => $exception->getLine(),
                'trace' => explode(PHP_EOL, $exception->getTraceAsString()),
            ]);
        }
        
        exit(1);
    }
}
